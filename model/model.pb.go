// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model/model.proto

package model

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type HashType int32

const (
	HashType_STRLEN HashType = 0
	HashType_SHA1   HashType = 1
	HashType_SHA256 HashType = 2
)

var HashType_name = map[int32]string{
	0: "STRLEN",
	1: "SHA1",
	2: "SHA256",
}

var HashType_value = map[string]int32{
	"STRLEN": 0,
	"SHA1":   1,
	"SHA256": 2,
}

func (x HashType) String() string {
	return proto.EnumName(HashType_name, int32(x))
}

func (HashType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{0}
}

//FileUploadRequest - Represents an upload request that is sent to the master.
type FileUploadRequest struct {
	Filename             string   `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	FileSize             int64    `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUploadRequest) Reset()         { *m = FileUploadRequest{} }
func (m *FileUploadRequest) String() string { return proto.CompactTextString(m) }
func (*FileUploadRequest) ProtoMessage()    {}
func (*FileUploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{0}
}

func (m *FileUploadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileUploadRequest.Unmarshal(m, b)
}
func (m *FileUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileUploadRequest.Marshal(b, m, deterministic)
}
func (m *FileUploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUploadRequest.Merge(m, src)
}
func (m *FileUploadRequest) XXX_Size() int {
	return xxx_messageInfo_FileUploadRequest.Size(m)
}
func (m *FileUploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileUploadRequest proto.InternalMessageInfo

func (m *FileUploadRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FileUploadRequest) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

//FileUploadResp - A response from the master about a file upload request.
type FileUploadResponse struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	EmpoweredMinion_IP   string   `protobuf:"bytes,2,opt,name=empowered_minion_IP,json=empoweredMinionIP,proto3" json:"empowered_minion_IP,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUploadResponse) Reset()         { *m = FileUploadResponse{} }
func (m *FileUploadResponse) String() string { return proto.CompactTextString(m) }
func (*FileUploadResponse) ProtoMessage()    {}
func (*FileUploadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{1}
}

func (m *FileUploadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileUploadResponse.Unmarshal(m, b)
}
func (m *FileUploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileUploadResponse.Marshal(b, m, deterministic)
}
func (m *FileUploadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUploadResponse.Merge(m, src)
}
func (m *FileUploadResponse) XXX_Size() int {
	return xxx_messageInfo_FileUploadResponse.Size(m)
}
func (m *FileUploadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUploadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileUploadResponse proto.InternalMessageInfo

func (m *FileUploadResponse) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *FileUploadResponse) GetEmpoweredMinion_IP() string {
	if m != nil {
		return m.EmpoweredMinion_IP
	}
	return ""
}

type FileReadRequest struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileReadRequest) Reset()         { *m = FileReadRequest{} }
func (m *FileReadRequest) String() string { return proto.CompactTextString(m) }
func (*FileReadRequest) ProtoMessage()    {}
func (*FileReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{2}
}

func (m *FileReadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileReadRequest.Unmarshal(m, b)
}
func (m *FileReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileReadRequest.Marshal(b, m, deterministic)
}
func (m *FileReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileReadRequest.Merge(m, src)
}
func (m *FileReadRequest) XXX_Size() int {
	return xxx_messageInfo_FileReadRequest.Size(m)
}
func (m *FileReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileReadRequest proto.InternalMessageInfo

func (m *FileReadRequest) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

type FileReadResponse struct {
	MinionServer_IP      string   `protobuf:"bytes,1,opt,name=minion_server_IP,json=minionServerIP,proto3" json:"minion_server_IP,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileReadResponse) Reset()         { *m = FileReadResponse{} }
func (m *FileReadResponse) String() string { return proto.CompactTextString(m) }
func (*FileReadResponse) ProtoMessage()    {}
func (*FileReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{3}
}

func (m *FileReadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileReadResponse.Unmarshal(m, b)
}
func (m *FileReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileReadResponse.Marshal(b, m, deterministic)
}
func (m *FileReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileReadResponse.Merge(m, src)
}
func (m *FileReadResponse) XXX_Size() int {
	return xxx_messageInfo_FileReadResponse.Size(m)
}
func (m *FileReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileReadResponse proto.InternalMessageInfo

func (m *FileReadResponse) GetMinionServer_IP() string {
	if m != nil {
		return m.MinionServer_IP
	}
	return ""
}

type FileChunk struct {
	Content              []byte   `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileChunk) Reset()         { *m = FileChunk{} }
func (m *FileChunk) String() string { return proto.CompactTextString(m) }
func (*FileChunk) ProtoMessage()    {}
func (*FileChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{4}
}

func (m *FileChunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileChunk.Unmarshal(m, b)
}
func (m *FileChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileChunk.Marshal(b, m, deterministic)
}
func (m *FileChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChunk.Merge(m, src)
}
func (m *FileChunk) XXX_Size() int {
	return xxx_messageInfo_FileChunk.Size(m)
}
func (m *FileChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChunk.DiscardUnknown(m)
}

var xxx_messageInfo_FileChunk proto.InternalMessageInfo

func (m *FileChunk) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type UploadRequest struct {
	// Types that are valid to be assigned to Data:
	//	*UploadRequest_Chunk
	//	*UploadRequest_UUID
	Data                 isUploadRequest_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UploadRequest) Reset()         { *m = UploadRequest{} }
func (m *UploadRequest) String() string { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()    {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{5}
}

func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadRequest.Unmarshal(m, b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
}
func (m *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(m, src)
}
func (m *UploadRequest) XXX_Size() int {
	return xxx_messageInfo_UploadRequest.Size(m)
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

type isUploadRequest_Data interface {
	isUploadRequest_Data()
}

type UploadRequest_Chunk struct {
	Chunk *FileChunk `protobuf:"bytes,1,opt,name=chunk,proto3,oneof"`
}

type UploadRequest_UUID struct {
	UUID string `protobuf:"bytes,2,opt,name=UUID,proto3,oneof"`
}

func (*UploadRequest_Chunk) isUploadRequest_Data() {}

func (*UploadRequest_UUID) isUploadRequest_Data() {}

func (m *UploadRequest) GetData() isUploadRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UploadRequest) GetChunk() *FileChunk {
	if x, ok := m.GetData().(*UploadRequest_Chunk); ok {
		return x.Chunk
	}
	return nil
}

func (m *UploadRequest) GetUUID() string {
	if x, ok := m.GetData().(*UploadRequest_UUID); ok {
		return x.UUID
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UploadRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UploadRequest_Chunk)(nil),
		(*UploadRequest_UUID)(nil),
	}
}

type DownloadRequest struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	ChunkSize            uint32   `protobuf:"varint,2,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadRequest) Reset()         { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()    {}
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{6}
}

func (m *DownloadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadRequest.Unmarshal(m, b)
}
func (m *DownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadRequest.Marshal(b, m, deterministic)
}
func (m *DownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadRequest.Merge(m, src)
}
func (m *DownloadRequest) XXX_Size() int {
	return xxx_messageInfo_DownloadRequest.Size(m)
}
func (m *DownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadRequest proto.InternalMessageInfo

func (m *DownloadRequest) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *DownloadRequest) GetChunkSize() uint32 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

//Hash the received file to assure the caller that we received it correctly.
type UploadResponse struct {
	Type                 HashType `protobuf:"varint,1,opt,name=type,proto3,enum=model.HashType" json:"type,omitempty"`
	HexHash              string   `protobuf:"bytes,2,opt,name=hex_hash,json=hexHash,proto3" json:"hex_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadResponse) Reset()         { *m = UploadResponse{} }
func (m *UploadResponse) String() string { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()    {}
func (*UploadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{7}
}

func (m *UploadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadResponse.Unmarshal(m, b)
}
func (m *UploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadResponse.Marshal(b, m, deterministic)
}
func (m *UploadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadResponse.Merge(m, src)
}
func (m *UploadResponse) XXX_Size() int {
	return xxx_messageInfo_UploadResponse.Size(m)
}
func (m *UploadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadResponse proto.InternalMessageInfo

func (m *UploadResponse) GetType() HashType {
	if m != nil {
		return m.Type
	}
	return HashType_STRLEN
}

func (m *UploadResponse) GetHexHash() string {
	if m != nil {
		return m.HexHash
	}
	return ""
}

func init() {
	proto.RegisterEnum("model.HashType", HashType_name, HashType_value)
	proto.RegisterType((*FileUploadRequest)(nil), "model.FileUploadRequest")
	proto.RegisterType((*FileUploadResponse)(nil), "model.FileUploadResponse")
	proto.RegisterType((*FileReadRequest)(nil), "model.FileReadRequest")
	proto.RegisterType((*FileReadResponse)(nil), "model.FileReadResponse")
	proto.RegisterType((*FileChunk)(nil), "model.FileChunk")
	proto.RegisterType((*UploadRequest)(nil), "model.UploadRequest")
	proto.RegisterType((*DownloadRequest)(nil), "model.DownloadRequest")
	proto.RegisterType((*UploadResponse)(nil), "model.UploadResponse")
}

func init() { proto.RegisterFile("model/model.proto", fileDescriptor_312ac5bcab6cbb43) }

var fileDescriptor_312ac5bcab6cbb43 = []byte{
	// 479 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x8d, 0x4b, 0x9a, 0x26, 0x43, 0x9b, 0x38, 0x43, 0x81, 0x34, 0x08, 0xa9, 0x32, 0x42, 0xb2,
	0x10, 0x0a, 0x60, 0x04, 0x07, 0xe0, 0x52, 0x1a, 0x90, 0x2d, 0xb5, 0x28, 0x72, 0x1a, 0xc1, 0x2d,
	0x32, 0xcd, 0x20, 0x5b, 0x24, 0xbb, 0xc6, 0xde, 0xd2, 0x8f, 0x1b, 0xff, 0x82, 0x9f, 0x5b, 0xed,
	0xac, 0x93, 0x38, 0x69, 0x2e, 0xd6, 0xee, 0xcc, 0x9b, 0x37, 0x6f, 0xe7, 0x8d, 0xa1, 0x3d, 0x93,
	0x13, 0x9a, 0xbe, 0xe2, 0x6f, 0x2f, 0xcd, 0xa4, 0x92, 0xb8, 0xcd, 0x17, 0xe7, 0x04, 0xda, 0x5f,
	0x93, 0x29, 0x8d, 0xd2, 0xa9, 0x8c, 0x26, 0x21, 0xfd, 0xb9, 0xa0, 0x5c, 0x61, 0x17, 0xea, 0xbf,
	0x92, 0x29, 0x89, 0x68, 0x46, 0x1d, 0xeb, 0xd0, 0x72, 0x1b, 0xe1, 0xe2, 0x8e, 0x4f, 0xa0, 0xa1,
	0xcf, 0xe3, 0x3c, 0xb9, 0xa1, 0xce, 0xd6, 0xa1, 0xe5, 0xde, 0x33, 0xc9, 0x61, 0x72, 0x43, 0xce,
	0x0f, 0xc0, 0x32, 0x5b, 0x9e, 0x4a, 0x91, 0x13, 0x22, 0x54, 0x47, 0xa3, 0xa0, 0x5f, 0x50, 0xf1,
	0x19, 0x7b, 0xf0, 0x80, 0x66, 0xa9, 0xbc, 0xa4, 0x8c, 0x26, 0xe3, 0x59, 0x22, 0x12, 0x29, 0xc6,
	0xc1, 0x80, 0x09, 0x1b, 0x61, 0x7b, 0x91, 0x3a, 0xe5, 0x4c, 0x30, 0x70, 0x9e, 0x43, 0x4b, 0x33,
	0x87, 0xb4, 0x54, 0xb9, 0x81, 0xd6, 0xf9, 0x04, 0xf6, 0x12, 0x56, 0xb4, 0x77, 0xc1, 0x2e, 0x1a,
	0xe4, 0x94, 0xfd, 0xa5, 0x4c, 0xf7, 0x31, 0x35, 0x4d, 0x13, 0x1f, 0x72, 0x98, 0x9b, 0x34, 0x74,
	0xf5, 0x71, 0x7c, 0x21, 0x7e, 0x63, 0x07, 0x76, 0xce, 0xa5, 0x50, 0x24, 0x14, 0xa3, 0x77, 0xc3,
	0xf9, 0xd5, 0xf9, 0x0e, 0x7b, 0xab, 0xf3, 0x72, 0x61, 0xfb, 0x5c, 0xd7, 0x30, 0xf0, 0xbe, 0x67,
	0xf7, 0xcc, 0xa0, 0x17, 0x5c, 0x7e, 0x25, 0x34, 0x00, 0xdc, 0x2f, 0x34, 0xf3, 0x3b, 0xfd, 0x8a,
	0x51, 0xfd, 0xb9, 0x06, 0xd5, 0x49, 0xa4, 0x22, 0xa7, 0x0f, 0xad, 0xbe, 0xbc, 0x14, 0x65, 0xea,
	0x4d, 0xb3, 0x7b, 0x0a, 0xc0, 0x6c, 0x4b, 0x0f, 0xf6, 0xc2, 0x06, 0x47, 0xd8, 0x84, 0x01, 0x34,
	0xd7, 0x0c, 0x78, 0x06, 0x55, 0x75, 0x9d, 0x1a, 0x2f, 0x9b, 0x5e, 0xab, 0x90, 0xe7, 0x47, 0x79,
	0x7c, 0x76, 0x9d, 0x52, 0xc8, 0x49, 0x3c, 0x80, 0x7a, 0x4c, 0x57, 0xe3, 0x38, 0xca, 0xe3, 0xc2,
	0x86, 0x9d, 0x98, 0xae, 0x34, 0xe8, 0xc5, 0x4b, 0xa8, 0xcf, 0xc1, 0x08, 0x50, 0x1b, 0x9e, 0x85,
	0x27, 0x5f, 0xbe, 0xd9, 0x15, 0xac, 0x43, 0x75, 0xe8, 0x1f, 0xbd, 0xb1, 0x2d, 0x8e, 0xfa, 0x47,
	0xde, 0xbb, 0xf7, 0xf6, 0x96, 0xf7, 0xdf, 0x82, 0xda, 0x69, 0x94, 0x2b, 0xca, 0x30, 0x00, 0x0c,
	0x44, 0xa2, 0x92, 0x48, 0xd1, 0x72, 0x2f, 0xb0, 0x53, 0x9a, 0xcf, 0xca, 0x20, 0xbb, 0x07, 0x1b,
	0x32, 0xc5, 0x1b, 0x8e, 0xc1, 0x2e, 0x53, 0x69, 0x87, 0xf1, 0x51, 0x09, 0x5e, 0xda, 0x8c, 0xee,
	0xe3, 0x3b, 0x71, 0x43, 0xe2, 0xfd, 0xd3, 0xd2, 0xd8, 0x73, 0xfc, 0x08, 0x60, 0x3a, 0x68, 0x10,
	0xee, 0x17, 0x15, 0xab, 0x72, 0x1e, 0xae, 0x45, 0x0d, 0x8b, 0x6b, 0xe1, 0x07, 0xd8, 0x9d, 0x1b,
	0xc5, 0xe5, 0x73, 0x21, 0x6b, 0xee, 0x75, 0xef, 0x6c, 0xc2, 0x6b, 0xeb, 0x67, 0x8d, 0xff, 0xbf,
	0xb7, 0xb7, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe7, 0x7b, 0xa3, 0x71, 0x94, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MasterClient is the client API for Master service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MasterClient interface {
	InitiateFileUpload(ctx context.Context, in *FileUploadRequest, opts ...grpc.CallOption) (*FileUploadResponse, error)
	InitiateFileRead(ctx context.Context, in *FileReadRequest, opts ...grpc.CallOption) (*FileReadResponse, error)
}

type masterClient struct {
	cc *grpc.ClientConn
}

func NewMasterClient(cc *grpc.ClientConn) MasterClient {
	return &masterClient{cc}
}

func (c *masterClient) InitiateFileUpload(ctx context.Context, in *FileUploadRequest, opts ...grpc.CallOption) (*FileUploadResponse, error) {
	out := new(FileUploadResponse)
	err := c.cc.Invoke(ctx, "/model.Master/InitiateFileUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) InitiateFileRead(ctx context.Context, in *FileReadRequest, opts ...grpc.CallOption) (*FileReadResponse, error) {
	out := new(FileReadResponse)
	err := c.cc.Invoke(ctx, "/model.Master/InitiateFileRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterServer is the server API for Master service.
type MasterServer interface {
	InitiateFileUpload(context.Context, *FileUploadRequest) (*FileUploadResponse, error)
	InitiateFileRead(context.Context, *FileReadRequest) (*FileReadResponse, error)
}

// UnimplementedMasterServer can be embedded to have forward compatible implementations.
type UnimplementedMasterServer struct {
}

func (*UnimplementedMasterServer) InitiateFileUpload(ctx context.Context, req *FileUploadRequest) (*FileUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateFileUpload not implemented")
}
func (*UnimplementedMasterServer) InitiateFileRead(ctx context.Context, req *FileReadRequest) (*FileReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateFileRead not implemented")
}

func RegisterMasterServer(s *grpc.Server, srv MasterServer) {
	s.RegisterService(&_Master_serviceDesc, srv)
}

func _Master_InitiateFileUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).InitiateFileUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Master/InitiateFileUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).InitiateFileUpload(ctx, req.(*FileUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_InitiateFileRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).InitiateFileRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Master/InitiateFileRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).InitiateFileRead(ctx, req.(*FileReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Master_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.Master",
	HandlerType: (*MasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateFileUpload",
			Handler:    _Master_InitiateFileUpload_Handler,
		},
		{
			MethodName: "InitiateFileRead",
			Handler:    _Master_InitiateFileRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model/model.proto",
}

// MinionClient is the client API for Minion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MinionClient interface {
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (Minion_UploadFileClient, error)
	DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Minion_DownloadFileClient, error)
}

type minionClient struct {
	cc *grpc.ClientConn
}

func NewMinionClient(cc *grpc.ClientConn) MinionClient {
	return &minionClient{cc}
}

func (c *minionClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (Minion_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Minion_serviceDesc.Streams[0], "/model.Minion/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &minionUploadFileClient{stream}
	return x, nil
}

type Minion_UploadFileClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*UploadResponse, error)
	grpc.ClientStream
}

type minionUploadFileClient struct {
	grpc.ClientStream
}

func (x *minionUploadFileClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *minionUploadFileClient) CloseAndRecv() (*UploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *minionClient) DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Minion_DownloadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Minion_serviceDesc.Streams[1], "/model.Minion/DownloadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &minionDownloadFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Minion_DownloadFileClient interface {
	Recv() (*FileChunk, error)
	grpc.ClientStream
}

type minionDownloadFileClient struct {
	grpc.ClientStream
}

func (x *minionDownloadFileClient) Recv() (*FileChunk, error) {
	m := new(FileChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MinionServer is the server API for Minion service.
type MinionServer interface {
	UploadFile(Minion_UploadFileServer) error
	DownloadFile(*DownloadRequest, Minion_DownloadFileServer) error
}

// UnimplementedMinionServer can be embedded to have forward compatible implementations.
type UnimplementedMinionServer struct {
}

func (*UnimplementedMinionServer) UploadFile(srv Minion_UploadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (*UnimplementedMinionServer) DownloadFile(req *DownloadRequest, srv Minion_DownloadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}

func RegisterMinionServer(s *grpc.Server, srv MinionServer) {
	s.RegisterService(&_Minion_serviceDesc, srv)
}

func _Minion_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MinionServer).UploadFile(&minionUploadFileServer{stream})
}

type Minion_UploadFileServer interface {
	SendAndClose(*UploadResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type minionUploadFileServer struct {
	grpc.ServerStream
}

func (x *minionUploadFileServer) SendAndClose(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *minionUploadFileServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Minion_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MinionServer).DownloadFile(m, &minionDownloadFileServer{stream})
}

type Minion_DownloadFileServer interface {
	Send(*FileChunk) error
	grpc.ServerStream
}

type minionDownloadFileServer struct {
	grpc.ServerStream
}

func (x *minionDownloadFileServer) Send(m *FileChunk) error {
	return x.ServerStream.SendMsg(m)
}

var _Minion_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.Minion",
	HandlerType: (*MinionServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _Minion_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFile",
			Handler:       _Minion_DownloadFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "model/model.proto",
}
