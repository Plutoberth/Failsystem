// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model/model.proto

package model

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type HashType int32

const (
	HashType_STRLEN HashType = 0
	HashType_SHA1   HashType = 1
	HashType_SHA256 HashType = 2
)

var HashType_name = map[int32]string{
	0: "STRLEN",
	1: "SHA1",
	2: "SHA256",
}

var HashType_value = map[string]int32{
	"STRLEN": 0,
	"SHA1":   1,
	"SHA256": 2,
}

func (x HashType) String() string {
	return proto.EnumName(HashType_name, int32(x))
}

func (HashType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{0}
}

type DataHash struct {
	Type                 HashType `protobuf:"varint,1,opt,name=type,proto3,enum=model.HashType" json:"type,omitempty"`
	HexHash              string   `protobuf:"bytes,2,opt,name=hexHash,proto3" json:"hexHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DataHash) Reset()         { *m = DataHash{} }
func (m *DataHash) String() string { return proto.CompactTextString(m) }
func (*DataHash) ProtoMessage()    {}
func (*DataHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{0}
}

func (m *DataHash) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DataHash.Unmarshal(m, b)
}
func (m *DataHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DataHash.Marshal(b, m, deterministic)
}
func (m *DataHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataHash.Merge(m, src)
}
func (m *DataHash) XXX_Size() int {
	return xxx_messageInfo_DataHash.Size(m)
}
func (m *DataHash) XXX_DiscardUnknown() {
	xxx_messageInfo_DataHash.DiscardUnknown(m)
}

var xxx_messageInfo_DataHash proto.InternalMessageInfo

func (m *DataHash) GetType() HashType {
	if m != nil {
		return m.Type
	}
	return HashType_STRLEN
}

func (m *DataHash) GetHexHash() string {
	if m != nil {
		return m.HexHash
	}
	return ""
}

type FileChunk struct {
	Content              []byte   `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileChunk) Reset()         { *m = FileChunk{} }
func (m *FileChunk) String() string { return proto.CompactTextString(m) }
func (*FileChunk) ProtoMessage()    {}
func (*FileChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{1}
}

func (m *FileChunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileChunk.Unmarshal(m, b)
}
func (m *FileChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileChunk.Marshal(b, m, deterministic)
}
func (m *FileChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChunk.Merge(m, src)
}
func (m *FileChunk) XXX_Size() int {
	return xxx_messageInfo_FileChunk.Size(m)
}
func (m *FileChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChunk.DiscardUnknown(m)
}

var xxx_messageInfo_FileChunk proto.InternalMessageInfo

func (m *FileChunk) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

//FileUploadRequest - Represents an upload request that is sent to the master.
type FileUploadRequest struct {
	FileName             string   `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	FileSize             int64    `protobuf:"varint,2,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUploadRequest) Reset()         { *m = FileUploadRequest{} }
func (m *FileUploadRequest) String() string { return proto.CompactTextString(m) }
func (*FileUploadRequest) ProtoMessage()    {}
func (*FileUploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{2}
}

func (m *FileUploadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileUploadRequest.Unmarshal(m, b)
}
func (m *FileUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileUploadRequest.Marshal(b, m, deterministic)
}
func (m *FileUploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUploadRequest.Merge(m, src)
}
func (m *FileUploadRequest) XXX_Size() int {
	return xxx_messageInfo_FileUploadRequest.Size(m)
}
func (m *FileUploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileUploadRequest proto.InternalMessageInfo

func (m *FileUploadRequest) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *FileUploadRequest) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

//FileUploadResp - A response from the master about a file upload request.
type FileUploadResponse struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	EmpoweredMinionIp    string   `protobuf:"bytes,2,opt,name=empoweredMinionIp,proto3" json:"empoweredMinionIp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUploadResponse) Reset()         { *m = FileUploadResponse{} }
func (m *FileUploadResponse) String() string { return proto.CompactTextString(m) }
func (*FileUploadResponse) ProtoMessage()    {}
func (*FileUploadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{3}
}

func (m *FileUploadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileUploadResponse.Unmarshal(m, b)
}
func (m *FileUploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileUploadResponse.Marshal(b, m, deterministic)
}
func (m *FileUploadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUploadResponse.Merge(m, src)
}
func (m *FileUploadResponse) XXX_Size() int {
	return xxx_messageInfo_FileUploadResponse.Size(m)
}
func (m *FileUploadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUploadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileUploadResponse proto.InternalMessageInfo

func (m *FileUploadResponse) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *FileUploadResponse) GetEmpoweredMinionIp() string {
	if m != nil {
		return m.EmpoweredMinionIp
	}
	return ""
}

type FileReadRequest struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileReadRequest) Reset()         { *m = FileReadRequest{} }
func (m *FileReadRequest) String() string { return proto.CompactTextString(m) }
func (*FileReadRequest) ProtoMessage()    {}
func (*FileReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{4}
}

func (m *FileReadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileReadRequest.Unmarshal(m, b)
}
func (m *FileReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileReadRequest.Marshal(b, m, deterministic)
}
func (m *FileReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileReadRequest.Merge(m, src)
}
func (m *FileReadRequest) XXX_Size() int {
	return xxx_messageInfo_FileReadRequest.Size(m)
}
func (m *FileReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileReadRequest proto.InternalMessageInfo

func (m *FileReadRequest) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

type FileReadResponse struct {
	MinionServerIp       string    `protobuf:"bytes,1,opt,name=minionServerIp,proto3" json:"minionServerIp,omitempty"`
	Hash                 *DataHash `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FileReadResponse) Reset()         { *m = FileReadResponse{} }
func (m *FileReadResponse) String() string { return proto.CompactTextString(m) }
func (*FileReadResponse) ProtoMessage()    {}
func (*FileReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{5}
}

func (m *FileReadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileReadResponse.Unmarshal(m, b)
}
func (m *FileReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileReadResponse.Marshal(b, m, deterministic)
}
func (m *FileReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileReadResponse.Merge(m, src)
}
func (m *FileReadResponse) XXX_Size() int {
	return xxx_messageInfo_FileReadResponse.Size(m)
}
func (m *FileReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileReadResponse proto.InternalMessageInfo

func (m *FileReadResponse) GetMinionServerIp() string {
	if m != nil {
		return m.MinionServerIp
	}
	return ""
}

func (m *FileReadResponse) GetHash() *DataHash {
	if m != nil {
		return m.Hash
	}
	return nil
}

type UploadRequest struct {
	// Types that are valid to be assigned to Data:
	//	*UploadRequest_Chunk
	//	*UploadRequest_UUID
	Data                 isUploadRequest_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UploadRequest) Reset()         { *m = UploadRequest{} }
func (m *UploadRequest) String() string { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()    {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{6}
}

func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadRequest.Unmarshal(m, b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
}
func (m *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(m, src)
}
func (m *UploadRequest) XXX_Size() int {
	return xxx_messageInfo_UploadRequest.Size(m)
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

type isUploadRequest_Data interface {
	isUploadRequest_Data()
}

type UploadRequest_Chunk struct {
	Chunk *FileChunk `protobuf:"bytes,1,opt,name=chunk,proto3,oneof"`
}

type UploadRequest_UUID struct {
	UUID string `protobuf:"bytes,2,opt,name=UUID,proto3,oneof"`
}

func (*UploadRequest_Chunk) isUploadRequest_Data() {}

func (*UploadRequest_UUID) isUploadRequest_Data() {}

func (m *UploadRequest) GetData() isUploadRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UploadRequest) GetChunk() *FileChunk {
	if x, ok := m.GetData().(*UploadRequest_Chunk); ok {
		return x.Chunk
	}
	return nil
}

func (m *UploadRequest) GetUUID() string {
	if x, ok := m.GetData().(*UploadRequest_UUID); ok {
		return x.UUID
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UploadRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UploadRequest_Chunk)(nil),
		(*UploadRequest_UUID)(nil),
	}
}

type DownloadRequest struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadRequest) Reset()         { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()    {}
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{7}
}

func (m *DownloadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownloadRequest.Unmarshal(m, b)
}
func (m *DownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownloadRequest.Marshal(b, m, deterministic)
}
func (m *DownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadRequest.Merge(m, src)
}
func (m *DownloadRequest) XXX_Size() int {
	return xxx_messageInfo_DownloadRequest.Size(m)
}
func (m *DownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadRequest proto.InternalMessageInfo

func (m *DownloadRequest) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

type AllocationRequest struct {
	//For categorization
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	FileSize             int64    `protobuf:"varint,2,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocationRequest) Reset()         { *m = AllocationRequest{} }
func (m *AllocationRequest) String() string { return proto.CompactTextString(m) }
func (*AllocationRequest) ProtoMessage()    {}
func (*AllocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{8}
}

func (m *AllocationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationRequest.Unmarshal(m, b)
}
func (m *AllocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationRequest.Marshal(b, m, deterministic)
}
func (m *AllocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationRequest.Merge(m, src)
}
func (m *AllocationRequest) XXX_Size() int {
	return xxx_messageInfo_AllocationRequest.Size(m)
}
func (m *AllocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationRequest proto.InternalMessageInfo

func (m *AllocationRequest) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *AllocationRequest) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

type AllocationResponse struct {
	//allocated is "true" if space has been allocated for the UUID in the minion.
	Allocated bool `protobuf:"varint,1,opt,name=allocated,proto3" json:"allocated,omitempty"`
	//availableSpace is the current available space if allocated is false, and the space after the allocation otherwise.
	AvailableSpace       int64    `protobuf:"varint,2,opt,name=availableSpace,proto3" json:"availableSpace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocationResponse) Reset()         { *m = AllocationResponse{} }
func (m *AllocationResponse) String() string { return proto.CompactTextString(m) }
func (*AllocationResponse) ProtoMessage()    {}
func (*AllocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{9}
}

func (m *AllocationResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationResponse.Unmarshal(m, b)
}
func (m *AllocationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationResponse.Marshal(b, m, deterministic)
}
func (m *AllocationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationResponse.Merge(m, src)
}
func (m *AllocationResponse) XXX_Size() int {
	return xxx_messageInfo_AllocationResponse.Size(m)
}
func (m *AllocationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationResponse proto.InternalMessageInfo

func (m *AllocationResponse) GetAllocated() bool {
	if m != nil {
		return m.Allocated
	}
	return false
}

func (m *AllocationResponse) GetAvailableSpace() int64 {
	if m != nil {
		return m.AvailableSpace
	}
	return 0
}

type EmpowermentRequest struct {
	//The UUID of the file that the server should be empowered for.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	//Servers that are ready to accept file writes using the mutual minion interface
	Subordinates         []string `protobuf:"bytes,2,rep,name=subordinates,proto3" json:"subordinates,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmpowermentRequest) Reset()         { *m = EmpowermentRequest{} }
func (m *EmpowermentRequest) String() string { return proto.CompactTextString(m) }
func (*EmpowermentRequest) ProtoMessage()    {}
func (*EmpowermentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{10}
}

func (m *EmpowermentRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmpowermentRequest.Unmarshal(m, b)
}
func (m *EmpowermentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmpowermentRequest.Marshal(b, m, deterministic)
}
func (m *EmpowermentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmpowermentRequest.Merge(m, src)
}
func (m *EmpowermentRequest) XXX_Size() int {
	return xxx_messageInfo_EmpowermentRequest.Size(m)
}
func (m *EmpowermentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EmpowermentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EmpowermentRequest proto.InternalMessageInfo

func (m *EmpowermentRequest) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *EmpowermentRequest) GetSubordinates() []string {
	if m != nil {
		return m.Subordinates
	}
	return nil
}

type EmpowermentResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmpowermentResponse) Reset()         { *m = EmpowermentResponse{} }
func (m *EmpowermentResponse) String() string { return proto.CompactTextString(m) }
func (*EmpowermentResponse) ProtoMessage()    {}
func (*EmpowermentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{11}
}

func (m *EmpowermentResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmpowermentResponse.Unmarshal(m, b)
}
func (m *EmpowermentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmpowermentResponse.Marshal(b, m, deterministic)
}
func (m *EmpowermentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmpowermentResponse.Merge(m, src)
}
func (m *EmpowermentResponse) XXX_Size() int {
	return xxx_messageInfo_EmpowermentResponse.Size(m)
}
func (m *EmpowermentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EmpowermentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EmpowermentResponse proto.InternalMessageInfo

type FileEntry struct {
	UUID                 string    `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	FileSize             int64     `protobuf:"varint,2,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	Hash                 *DataHash `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FileEntry) Reset()         { *m = FileEntry{} }
func (m *FileEntry) String() string { return proto.CompactTextString(m) }
func (*FileEntry) ProtoMessage()    {}
func (*FileEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{12}
}

func (m *FileEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileEntry.Unmarshal(m, b)
}
func (m *FileEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileEntry.Marshal(b, m, deterministic)
}
func (m *FileEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileEntry.Merge(m, src)
}
func (m *FileEntry) XXX_Size() int {
	return xxx_messageInfo_FileEntry.Size(m)
}
func (m *FileEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_FileEntry.DiscardUnknown(m)
}

var xxx_messageInfo_FileEntry proto.InternalMessageInfo

func (m *FileEntry) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *FileEntry) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *FileEntry) GetHash() *DataHash {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Announcement struct {
	UUID                 string       `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Entries              []*FileEntry `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries,omitempty"`
	AvailableSpace       int64        `protobuf:"varint,3,opt,name=availableSpace,proto3" json:"availableSpace,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Announcement) Reset()         { *m = Announcement{} }
func (m *Announcement) String() string { return proto.CompactTextString(m) }
func (*Announcement) ProtoMessage()    {}
func (*Announcement) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{13}
}

func (m *Announcement) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Announcement.Unmarshal(m, b)
}
func (m *Announcement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Announcement.Marshal(b, m, deterministic)
}
func (m *Announcement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Announcement.Merge(m, src)
}
func (m *Announcement) XXX_Size() int {
	return xxx_messageInfo_Announcement.Size(m)
}
func (m *Announcement) XXX_DiscardUnknown() {
	xxx_messageInfo_Announcement.DiscardUnknown(m)
}

var xxx_messageInfo_Announcement proto.InternalMessageInfo

func (m *Announcement) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *Announcement) GetEntries() []*FileEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Announcement) GetAvailableSpace() int64 {
	if m != nil {
		return m.AvailableSpace
	}
	return 0
}

type AnnounceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnnounceResponse) Reset()         { *m = AnnounceResponse{} }
func (m *AnnounceResponse) String() string { return proto.CompactTextString(m) }
func (*AnnounceResponse) ProtoMessage()    {}
func (*AnnounceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_312ac5bcab6cbb43, []int{14}
}

func (m *AnnounceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnnounceResponse.Unmarshal(m, b)
}
func (m *AnnounceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnnounceResponse.Marshal(b, m, deterministic)
}
func (m *AnnounceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnnounceResponse.Merge(m, src)
}
func (m *AnnounceResponse) XXX_Size() int {
	return xxx_messageInfo_AnnounceResponse.Size(m)
}
func (m *AnnounceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AnnounceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AnnounceResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("model.HashType", HashType_name, HashType_value)
	proto.RegisterType((*DataHash)(nil), "model.DataHash")
	proto.RegisterType((*FileChunk)(nil), "model.FileChunk")
	proto.RegisterType((*FileUploadRequest)(nil), "model.FileUploadRequest")
	proto.RegisterType((*FileUploadResponse)(nil), "model.FileUploadResponse")
	proto.RegisterType((*FileReadRequest)(nil), "model.FileReadRequest")
	proto.RegisterType((*FileReadResponse)(nil), "model.FileReadResponse")
	proto.RegisterType((*UploadRequest)(nil), "model.UploadRequest")
	proto.RegisterType((*DownloadRequest)(nil), "model.DownloadRequest")
	proto.RegisterType((*AllocationRequest)(nil), "model.AllocationRequest")
	proto.RegisterType((*AllocationResponse)(nil), "model.AllocationResponse")
	proto.RegisterType((*EmpowermentRequest)(nil), "model.EmpowermentRequest")
	proto.RegisterType((*EmpowermentResponse)(nil), "model.EmpowermentResponse")
	proto.RegisterType((*FileEntry)(nil), "model.FileEntry")
	proto.RegisterType((*Announcement)(nil), "model.Announcement")
	proto.RegisterType((*AnnounceResponse)(nil), "model.AnnounceResponse")
}

func init() { proto.RegisterFile("model/model.proto", fileDescriptor_312ac5bcab6cbb43) }

var fileDescriptor_312ac5bcab6cbb43 = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdf, 0x6f, 0x12, 0x41,
	0x10, 0xee, 0x15, 0x4a, 0x8f, 0x29, 0xd2, 0x63, 0x5b, 0x15, 0x89, 0x0f, 0xcd, 0x99, 0x1a, 0xd2,
	0x34, 0x55, 0x31, 0x35, 0xc6, 0x17, 0xc5, 0xb6, 0x06, 0xb4, 0xed, 0xc3, 0x41, 0x35, 0xf1, 0x45,
	0xb7, 0x30, 0x86, 0x8b, 0xc7, 0xee, 0x79, 0xb7, 0xb4, 0xa2, 0x7f, 0x86, 0x2f, 0xfe, 0xb9, 0xe6,
	0xf6, 0xc7, 0x71, 0xc0, 0x85, 0xc4, 0x17, 0xc2, 0xce, 0xcc, 0x7e, 0xf3, 0xed, 0x37, 0xf3, 0xe5,
	0xa0, 0x36, 0xe6, 0x43, 0x0c, 0x9e, 0xc8, 0xdf, 0xa3, 0x30, 0xe2, 0x82, 0x93, 0x0d, 0x79, 0x70,
	0xbb, 0x60, 0x9f, 0x52, 0x41, 0x3b, 0x34, 0x1e, 0x91, 0x47, 0x50, 0x14, 0xd3, 0x10, 0xeb, 0xd6,
	0x9e, 0xd5, 0xac, 0xb6, 0xb6, 0x8f, 0x54, 0x79, 0x92, 0xea, 0x4f, 0x43, 0xf4, 0x64, 0x92, 0xd4,
	0x61, 0x73, 0x84, 0x3f, 0x93, 0x60, 0x7d, 0x7d, 0xcf, 0x6a, 0x96, 0x3d, 0x73, 0x74, 0xf7, 0xa1,
	0xfc, 0xce, 0x0f, 0xf0, 0x64, 0x34, 0x61, 0xdf, 0x93, 0xb2, 0x01, 0x67, 0x02, 0x99, 0x90, 0x70,
	0x15, 0xcf, 0x1c, 0xdd, 0x0f, 0x50, 0x4b, 0xca, 0xae, 0xc2, 0x80, 0xd3, 0xa1, 0x87, 0x3f, 0x26,
	0x18, 0x0b, 0xd2, 0x00, 0xfb, 0x9b, 0x1f, 0xe0, 0x25, 0x1d, 0xab, 0xf6, 0x65, 0x2f, 0x3d, 0x9b,
	0x5c, 0xcf, 0xff, 0x85, 0xb2, 0x65, 0xc1, 0x4b, 0xcf, 0xee, 0x47, 0x20, 0x59, 0xb0, 0x38, 0xe4,
	0x2c, 0x46, 0x42, 0xa0, 0x78, 0x75, 0xd5, 0x3d, 0xd5, 0x48, 0xf2, 0x3f, 0x39, 0x84, 0x1a, 0x8e,
	0x43, 0x7e, 0x8b, 0x11, 0x0e, 0x2f, 0x7c, 0xe6, 0x73, 0xd6, 0x0d, 0xf5, 0x0b, 0x96, 0x13, 0xee,
	0x3e, 0x6c, 0x27, 0xb8, 0x1e, 0xce, 0x28, 0xe6, 0x80, 0xba, 0x5f, 0xc0, 0x99, 0x95, 0xe9, 0xe6,
	0x8f, 0xa1, 0x3a, 0x96, 0x30, 0x3d, 0x8c, 0x6e, 0x30, 0xea, 0x86, 0xfa, 0xc6, 0x42, 0x34, 0x51,
	0x7b, 0x64, 0x54, 0xdc, 0x4a, 0xd5, 0x36, 0xc3, 0xf0, 0x64, 0xd2, 0xfd, 0x04, 0x77, 0xe6, 0x85,
	0x6a, 0xc2, 0xc6, 0x20, 0x11, 0x58, 0x82, 0x6e, 0xb5, 0x1c, 0x7d, 0x2d, 0x15, 0xbe, 0xb3, 0xe6,
	0xa9, 0x02, 0xb2, 0xab, 0xf9, 0xca, 0x37, 0x76, 0xd6, 0x14, 0xe3, 0xb7, 0x25, 0x28, 0x0e, 0xa9,
	0xa0, 0xc9, 0x03, 0x4f, 0xf9, 0x2d, 0xcb, 0x42, 0xe7, 0x3d, 0xf0, 0x04, 0x6a, 0xed, 0x20, 0xe0,
	0x03, 0x2a, 0x7c, 0xce, 0x56, 0x14, 0xae, 0x1c, 0xd2, 0x67, 0x20, 0x59, 0x10, 0xad, 0xd3, 0x43,
	0x28, 0x53, 0x15, 0xc5, 0xa1, 0x84, 0xb2, 0xbd, 0x59, 0x20, 0x51, 0x91, 0xde, 0x50, 0x3f, 0xa0,
	0xd7, 0x01, 0xf6, 0x42, 0x3a, 0x30, 0xa8, 0x0b, 0x51, 0xf7, 0x1c, 0xc8, 0x99, 0x9a, 0xde, 0x18,
	0x99, 0x58, 0xc5, 0xd0, 0x85, 0x4a, 0x3c, 0xb9, 0xe6, 0xd1, 0xd0, 0x67, 0x54, 0x60, 0x5c, 0x5f,
	0xdf, 0x2b, 0x34, 0xcb, 0xde, 0x5c, 0xcc, 0xbd, 0x0b, 0x3b, 0x73, 0x68, 0x8a, 0xaa, 0xfb, 0x55,
	0x6d, 0xf6, 0x19, 0x13, 0xd1, 0xf4, 0x7f, 0x5f, 0x9f, 0xce, 0xb9, 0xb0, 0x6a, 0xce, 0x37, 0x50,
	0x69, 0x33, 0xc6, 0x27, 0x6c, 0x80, 0x49, 0xe7, 0xdc, 0x26, 0x07, 0xb0, 0x89, 0x4c, 0x44, 0xbe,
	0xe6, 0x3e, 0x3f, 0x7c, 0xc9, 0xcd, 0x33, 0x05, 0x39, 0xf2, 0x15, 0x72, 0xe5, 0x23, 0xe0, 0x98,
	0xbe, 0xe6, 0xb5, 0x07, 0x87, 0x60, 0x1b, 0xcf, 0x13, 0x80, 0x52, 0xaf, 0xef, 0x9d, 0x9f, 0x5d,
	0x3a, 0x6b, 0xc4, 0x86, 0x62, 0xaf, 0xd3, 0x7e, 0xe6, 0x58, 0x32, 0xda, 0x69, 0xb7, 0x8e, 0x5f,
	0x38, 0xeb, 0xad, 0xbf, 0x16, 0x94, 0x2e, 0x68, 0x2c, 0x30, 0x22, 0x5d, 0x20, 0x5d, 0xe6, 0x0b,
	0x9f, 0x0a, 0x9c, 0x99, 0x92, 0xd4, 0x33, 0x2c, 0xe7, 0x76, 0xb9, 0xf1, 0x20, 0x27, 0xa3, 0x97,
	0xe3, 0x04, 0x9c, 0x2c, 0x54, 0x62, 0x30, 0x72, 0x2f, 0x53, 0x9e, 0x31, 0x66, 0xe3, 0xfe, 0x52,
	0x5c, 0x81, 0xb4, 0x7e, 0x43, 0x49, 0x19, 0x9a, 0x1c, 0x03, 0xa8, 0x06, 0x49, 0x0d, 0xd9, 0xd5,
	0x17, 0xe6, 0xd9, 0x2c, 0x4e, 0xa6, 0x69, 0x91, 0x57, 0x50, 0x31, 0x26, 0x91, 0x17, 0x0d, 0x83,
	0x05, 0xe7, 0x34, 0x96, 0x5c, 0xf8, 0xd4, 0x6a, 0xfd, 0xb1, 0xa0, 0xaa, 0x74, 0xe9, 0x73, 0xcd,
	0xe2, 0x35, 0xd8, 0xda, 0x07, 0x98, 0xaa, 0xb2, 0xe4, 0xae, 0x54, 0x95, 0x1c, 0xcb, 0xbc, 0x81,
	0x4d, 0xbd, 0x9e, 0xc4, 0x54, 0x2d, 0x2f, 0x7f, 0xa3, 0x91, 0x97, 0xd2, 0x92, 0xbc, 0x87, 0xaa,
	0x22, 0xd3, 0xe7, 0x7a, 0x68, 0x2f, 0xc1, 0x36, 0x1b, 0x40, 0x76, 0x4c, 0xeb, 0xcc, 0x2a, 0xa6,
	0xf2, 0x2e, 0xee, 0xc9, 0x75, 0x49, 0x7e, 0x48, 0x9e, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x22,
	0x2f, 0xff, 0x2f, 0x5d, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MasterClient is the client API for Master service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MasterClient interface {
	InitiateFileUpload(ctx context.Context, in *FileUploadRequest, opts ...grpc.CallOption) (*FileUploadResponse, error)
	InitiateFileRead(ctx context.Context, in *FileReadRequest, opts ...grpc.CallOption) (*FileReadResponse, error)
}

type masterClient struct {
	cc *grpc.ClientConn
}

func NewMasterClient(cc *grpc.ClientConn) MasterClient {
	return &masterClient{cc}
}

func (c *masterClient) InitiateFileUpload(ctx context.Context, in *FileUploadRequest, opts ...grpc.CallOption) (*FileUploadResponse, error) {
	out := new(FileUploadResponse)
	err := c.cc.Invoke(ctx, "/model.Master/InitiateFileUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) InitiateFileRead(ctx context.Context, in *FileReadRequest, opts ...grpc.CallOption) (*FileReadResponse, error) {
	out := new(FileReadResponse)
	err := c.cc.Invoke(ctx, "/model.Master/InitiateFileRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterServer is the server API for Master service.
type MasterServer interface {
	InitiateFileUpload(context.Context, *FileUploadRequest) (*FileUploadResponse, error)
	InitiateFileRead(context.Context, *FileReadRequest) (*FileReadResponse, error)
}

// UnimplementedMasterServer can be embedded to have forward compatible implementations.
type UnimplementedMasterServer struct {
}

func (*UnimplementedMasterServer) InitiateFileUpload(ctx context.Context, req *FileUploadRequest) (*FileUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateFileUpload not implemented")
}
func (*UnimplementedMasterServer) InitiateFileRead(ctx context.Context, req *FileReadRequest) (*FileReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateFileRead not implemented")
}

func RegisterMasterServer(s *grpc.Server, srv MasterServer) {
	s.RegisterService(&_Master_serviceDesc, srv)
}

func _Master_InitiateFileUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).InitiateFileUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Master/InitiateFileUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).InitiateFileUpload(ctx, req.(*FileUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_InitiateFileRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).InitiateFileRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.Master/InitiateFileRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).InitiateFileRead(ctx, req.(*FileReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Master_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.Master",
	HandlerType: (*MasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateFileUpload",
			Handler:    _Master_InitiateFileUpload_Handler,
		},
		{
			MethodName: "InitiateFileRead",
			Handler:    _Master_InitiateFileRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model/model.proto",
}

// MinionClient is the client API for Minion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MinionClient interface {
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (Minion_UploadFileClient, error)
	DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Minion_DownloadFileClient, error)
}

type minionClient struct {
	cc *grpc.ClientConn
}

func NewMinionClient(cc *grpc.ClientConn) MinionClient {
	return &minionClient{cc}
}

func (c *minionClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (Minion_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Minion_serviceDesc.Streams[0], "/model.Minion/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &minionUploadFileClient{stream}
	return x, nil
}

type Minion_UploadFileClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*DataHash, error)
	grpc.ClientStream
}

type minionUploadFileClient struct {
	grpc.ClientStream
}

func (x *minionUploadFileClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *minionUploadFileClient) CloseAndRecv() (*DataHash, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(DataHash)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *minionClient) DownloadFile(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Minion_DownloadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Minion_serviceDesc.Streams[1], "/model.Minion/DownloadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &minionDownloadFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Minion_DownloadFileClient interface {
	Recv() (*FileChunk, error)
	grpc.ClientStream
}

type minionDownloadFileClient struct {
	grpc.ClientStream
}

func (x *minionDownloadFileClient) Recv() (*FileChunk, error) {
	m := new(FileChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MinionServer is the server API for Minion service.
type MinionServer interface {
	UploadFile(Minion_UploadFileServer) error
	DownloadFile(*DownloadRequest, Minion_DownloadFileServer) error
}

// UnimplementedMinionServer can be embedded to have forward compatible implementations.
type UnimplementedMinionServer struct {
}

func (*UnimplementedMinionServer) UploadFile(srv Minion_UploadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (*UnimplementedMinionServer) DownloadFile(req *DownloadRequest, srv Minion_DownloadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}

func RegisterMinionServer(s *grpc.Server, srv MinionServer) {
	s.RegisterService(&_Minion_serviceDesc, srv)
}

func _Minion_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MinionServer).UploadFile(&minionUploadFileServer{stream})
}

type Minion_UploadFileServer interface {
	SendAndClose(*DataHash) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type minionUploadFileServer struct {
	grpc.ServerStream
}

func (x *minionUploadFileServer) SendAndClose(m *DataHash) error {
	return x.ServerStream.SendMsg(m)
}

func (x *minionUploadFileServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Minion_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MinionServer).DownloadFile(m, &minionDownloadFileServer{stream})
}

type Minion_DownloadFileServer interface {
	Send(*FileChunk) error
	grpc.ServerStream
}

type minionDownloadFileServer struct {
	grpc.ServerStream
}

func (x *minionDownloadFileServer) Send(m *FileChunk) error {
	return x.ServerStream.SendMsg(m)
}

var _Minion_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.Minion",
	HandlerType: (*MinionServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _Minion_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFile",
			Handler:       _Minion_DownloadFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "model/model.proto",
}

// MasterToMinionClient is the client API for MasterToMinion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MasterToMinionClient interface {
	Allocate(ctx context.Context, in *AllocationRequest, opts ...grpc.CallOption) (*AllocationResponse, error)
	Empower(ctx context.Context, in *EmpowermentRequest, opts ...grpc.CallOption) (*EmpowermentResponse, error)
}

type masterToMinionClient struct {
	cc *grpc.ClientConn
}

func NewMasterToMinionClient(cc *grpc.ClientConn) MasterToMinionClient {
	return &masterToMinionClient{cc}
}

func (c *masterToMinionClient) Allocate(ctx context.Context, in *AllocationRequest, opts ...grpc.CallOption) (*AllocationResponse, error) {
	out := new(AllocationResponse)
	err := c.cc.Invoke(ctx, "/model.MasterToMinion/Allocate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterToMinionClient) Empower(ctx context.Context, in *EmpowermentRequest, opts ...grpc.CallOption) (*EmpowermentResponse, error) {
	out := new(EmpowermentResponse)
	err := c.cc.Invoke(ctx, "/model.MasterToMinion/Empower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterToMinionServer is the server API for MasterToMinion service.
type MasterToMinionServer interface {
	Allocate(context.Context, *AllocationRequest) (*AllocationResponse, error)
	Empower(context.Context, *EmpowermentRequest) (*EmpowermentResponse, error)
}

// UnimplementedMasterToMinionServer can be embedded to have forward compatible implementations.
type UnimplementedMasterToMinionServer struct {
}

func (*UnimplementedMasterToMinionServer) Allocate(ctx context.Context, req *AllocationRequest) (*AllocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Allocate not implemented")
}
func (*UnimplementedMasterToMinionServer) Empower(ctx context.Context, req *EmpowermentRequest) (*EmpowermentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Empower not implemented")
}

func RegisterMasterToMinionServer(s *grpc.Server, srv MasterToMinionServer) {
	s.RegisterService(&_MasterToMinion_serviceDesc, srv)
}

func _MasterToMinion_Allocate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterToMinionServer).Allocate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.MasterToMinion/Allocate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterToMinionServer).Allocate(ctx, req.(*AllocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterToMinion_Empower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmpowermentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterToMinionServer).Empower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.MasterToMinion/Empower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterToMinionServer).Empower(ctx, req.(*EmpowermentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MasterToMinion_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.MasterToMinion",
	HandlerType: (*MasterToMinionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Allocate",
			Handler:    _MasterToMinion_Allocate_Handler,
		},
		{
			MethodName: "Empower",
			Handler:    _MasterToMinion_Empower_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model/model.proto",
}

// MinionToMasterClient is the client API for MinionToMaster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MinionToMasterClient interface {
	//Announce the Minion's existence to the Master.
	Announce(ctx context.Context, in *Announcement, opts ...grpc.CallOption) (*AnnounceResponse, error)
}

type minionToMasterClient struct {
	cc *grpc.ClientConn
}

func NewMinionToMasterClient(cc *grpc.ClientConn) MinionToMasterClient {
	return &minionToMasterClient{cc}
}

func (c *minionToMasterClient) Announce(ctx context.Context, in *Announcement, opts ...grpc.CallOption) (*AnnounceResponse, error) {
	out := new(AnnounceResponse)
	err := c.cc.Invoke(ctx, "/model.MinionToMaster/Announce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MinionToMasterServer is the server API for MinionToMaster service.
type MinionToMasterServer interface {
	//Announce the Minion's existence to the Master.
	Announce(context.Context, *Announcement) (*AnnounceResponse, error)
}

// UnimplementedMinionToMasterServer can be embedded to have forward compatible implementations.
type UnimplementedMinionToMasterServer struct {
}

func (*UnimplementedMinionToMasterServer) Announce(ctx context.Context, req *Announcement) (*AnnounceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Announce not implemented")
}

func RegisterMinionToMasterServer(s *grpc.Server, srv MinionToMasterServer) {
	s.RegisterService(&_MinionToMaster_serviceDesc, srv)
}

func _MinionToMaster_Announce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Announcement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinionToMasterServer).Announce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.MinionToMaster/Announce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinionToMasterServer).Announce(ctx, req.(*Announcement))
	}
	return interceptor(ctx, in, info, handler)
}

var _MinionToMaster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.MinionToMaster",
	HandlerType: (*MinionToMasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Announce",
			Handler:    _MinionToMaster_Announce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model/model.proto",
}
